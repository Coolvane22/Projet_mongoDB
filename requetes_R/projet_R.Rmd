---
title: "Projet MongoDB"
author: "GOUTARD Amélie & THIVEND Evane"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Librairies
```{r}
lib <- c("tidyverse", "mongolite", "rlist", "visNetwork")
sapply(lib, require, character = TRUE)

```

# Connexion à la base de données
```{r}

mdb = mongo(
  collection = "hal_irisa_2021",
  url = "mongodb+srv://etudiant:ur2@clusterm1.0rm7t.mongodb.net/publications",
  verbose = TRUE
)

```


# Récupération des données nécessaires pour la visualisation  
Votre requête MongoDB devra récupérer pour chacun de ces auteurs la liste de ses publications (la suite du traitement qui consiste à calculer le nombre d’articles commun par paire d’auteurs pourra être réalisée dans votre script).  
```{r}
req <- '[
  {"$unwind" : "$authors"},
  {"$sort" : {"_id" : 1} } 
]'

data <- mdb$aggregate(pipeline = req)


## on garde uniquement les 20 auteurs qui ont participe a l'ecriture du plus grand nombre d'articles et pour chaque auteur on recupere la liste de ses publications
req <- '[
  {"$unwind" : "$authors"},
  {"$group" : {"_id" : "$authors",
               "liste_publi" : {"$push" : {"halId" : "$halId"} },
               "nb": {"$sum" : 1} }
  },
  {"$sort" : {"nb" : -1} },
  {"$limit" : 20}
]'

data = mdb$aggregate(pipeline = req)

# on stocke dans un tibble avec une structure plus claire (une colonne pour name et firstname)
data <- tibble(
  name = data$"_id"$name,
  firstname = data$"_id"$firstname,
  liste_publi = data$liste_publi,
  nb = data$nb
) %>%
  # on ajoute une colonne qui contient le nom et prenom de chaque auteur
  mutate("nom_prenom" = paste(name, firstname, sep = " ")) 

```


# Liens entre auteurs (co-publications)
```{r}
data_final <- data %>%
  # on souhaites qu'il y ai autant de lignes par auteur qu'il a participe a des publications
  select(nom_prenom, liste_publi) %>%
  unnest_longer(liste_publi)

## les differentes paires d'auteurs possible
v <- distinct(data_final, nom_prenom) %>% pull()
paires_auteurs <- expand.grid("auteur1" = v , "auteur2" = v) %>% 
  filter(auteur1 != auteur2)

## on veut le nombre de publications en commun entre chaque paire d'auteurs
crosstable <- table(data_final$liste_publi$halId, data_final$nom_prenom)

paires_auteurs$nb_publi_commun <- apply(paires_auteurs, MARGIN = 1, FUN = function(x){
  i = 1
  vec = c()
  while(i <= nrow(crosstable)){
    vec = c(vec, sum(crosstable[i,c(x[1],x[2])][1] == 1 & crosstable[i,c(x[1],x[2])][2] == 1))
    i = i +1
  }
  x[3] = sum(vec)
})

# on a les paires d'auteurs "aller-retour", on peut les supprimer, a voir si besoin pour la visualisation

# for(link1 in paires_auteurs){
#   for(link2 in paires_auteurs){
#     if (link1 != link2){
#       tibble %>% add_row(link1)
#     }
#   }
# }

```

# Visualisation
```{r}
## noeuds 
nodes <- data %>% 
  select(nom_prenom, nb) %>% 
  # ajout d'un groupe pour chaque auteur en fonction du nombre de publications
  mutate(group = ifelse(nb>12,"High", ifelse(nb>10, "Medium", "Low"))) %>% 
  select(-nb) %>% 
  dplyr::rename(id = nom_prenom) %>% 
  mutate("title" = id)

## liens
edges <- paires_auteurs %>% 
  filter(nb_publi_commun != 0) %>% 
  dplyr::rename(from = auteur1, to = auteur2, weight = nb_publi_commun) %>% 
  mutate(value = weight)

## representation graphique
visNetwork(nodes, edges) %>% 
  visInteraction(dragView = TRUE,navigationButtons = TRUE) %>%
  visPhysics(solver = "forceAtlas2Based", 
             forceAtlas2Based = list(gravitationalConstant = -60)) %>%
  visLayout(randomSeed = 12) %>% 
  # choix du groupe 
  visOptions(selectedBy = "group", highlightNearest = list(enabled = T, degree = 1, hover = T))
```
Exemple de bonus : Vous pourrez faire en sorte que l’épaisseur des traits joignant les auteurs soit proportionnelle au nombre de publications communes.
